# Next.js多语言网站翻译方案

## 总体架构

我们的多语言游戏网站采用基于Next.js App Router的多语言实现方案，具有以下特点：

1. **基于路由的语言切换**：
   - 使用`[locale]`参数化路由段实现多语言URL结构
   - 例如：`/en/games`、`/zh/games`等路径

2. **中间件自动语言检测**：
   - 使用`middleware.ts`检测用户浏览器语言
   - 自动重定向到相应的语言版本

3. **双轨制翻译管理**：
   - 公共组件：使用共享翻译文件
   - 私有组件：在组件内部管理翻译

## 翻译实现方式

### 1. 共享翻译文件

对于公共组件和共享文本，使用集中式翻译文件：

```
src/
  messages/
    en.json
    zh.json
    es.json
    fr.json
```

翻译文件结构示例：

```json
{
  "navigation": {
    "home": "Home",
    "games": "Games",
    "about": "About Us"
  },
  "footer": {
    "copyright": "© 2025 All rights reserved",
    "privacy": "Privacy Policy"
  },
  "common": {
    "loading": "Loading...",
    "error": "An error occurred"
  }
}
```

### 2. 翻译辅助函数

使用自定义辅助函数访问嵌套翻译键：

```tsx
// src/lib/translateHelper.ts
export function getTranslation(
  obj: Record<string, any> | undefined, 
  path: string,
  defaultValue: string = path
): string {
  if (!obj) return defaultValue;
  
  const keys = path.split('.');
  let value = obj;
  
  // 遍历嵌套路径
  for (const key of keys) {
    value = value?.[key];
    
    // 如果找不到键，返回默认值
    if (value === undefined) {
      return defaultValue;
    }
  }
  
  // 如果值不是字符串，返回默认值
  return typeof value === 'string' ? value : defaultValue;
}
```

### 3. 预加载翻译数据

确保服务器端和客户端使用相同的翻译数据：

```tsx
// src/lib/getMessages.ts
import { Locale, defaultLocale } from '@/app/config/i18n'
import en from '@/messages/en.json'
import zh from '@/messages/zh.json'
import es from '@/messages/es.json'
import fr from '@/messages/fr.json'

// 预加载翻译数据，避免客户端动态导入
const translations: Record<Locale, any> = {
  en, zh, es, fr
};

export async function getMessages(locale: Locale) {
  return translations[locale] || translations[defaultLocale];
}
```

### 4. 在组件中使用共享翻译

```tsx
// 在组件中使用
const t = (path: string, defaultValue: string = path) => 
  getTranslation(messages, path, defaultValue);

// 使用示例
<div>{t('navigation.home', 'Home')}</div>
```

## 私有化组件翻译管理原则

### 1. 组件内部翻译管理

- 私有化的组件和页面需要在自己的组件内部管理翻译内容
- 不依赖公共语言包（src/messages/）中的翻译

### 2. 实现方式

在组件文件内部定义翻译对象：

```tsx
// 组件内部定义翻译
const translations = {
  en: {
    title: 'My Component Title',
    description: 'This is a private component'
  },
  zh: {
    title: '我的组件标题',
    description: '这是一个私有组件'
  },
  // 其他语言...
};
```

### 3. 翻译使用

组件通过props接收当前语言代码：

```tsx
interface MyComponentProps {
  locale: Locale;
  // 其他props...
}

const MyComponent = ({ locale }: MyComponentProps) => {
  // 使用当前语言的翻译，如果不存在则使用英文
  const t = translations[locale] || translations.en;
  
  return (
    <div>
      <h2>{t.title}</h2>
      <p>{t.description}</p>
    </div>
  );
};
```

## 组件分类与翻译策略

### 共享组件（使用公共翻译文件）

1. **布局组件**：
   - Header
   - Footer
   - Navigation

2. **通用UI组件**：
   - Button
   - Alert
   - Modal
   - Pagination

3. **全站共享功能组件**：
   - LanguageSwitcher
   - SearchBar
   - CategoryFilter

### 私有组件（内部管理翻译）

1. **特定业务组件**：
   - GameCard
   - GameDetail
   - CategoryList

2. **页面特定组件**：
   - HomePage特有组件
   - AboutPage特有组件
   - 各游戏页面特有组件

3. **实验性功能组件**：
   - 新功能试验
   - A/B测试组件

## 翻译文件组织

### 公共翻译文件结构

```
src/messages/
  en.json
  zh.json
  es.json
  fr.json
```

建议的JSON结构：

```
{
  "common": { ... },  // 通用文本
  "navigation": { ... },  // 导航相关
  "footer": { ... },  // 页脚相关
  "errors": { ... },  // 错误信息
  "ui": { ... }  // UI元素文本
}
```

### 私有组件翻译

私有组件的翻译直接定义在组件文件中，或者在组件同目录下创建翻译文件：

```
src/components/
  GameCard/
    index.tsx
    translations.ts  // 组件特定翻译
```

## 语言切换实现

### LanguageSwitcher组件

```tsx
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { useParams } from 'next/navigation'
import { Locale, locales, localeNames } from '@/app/config/i18n'

export function LanguageSwitcher({
  variant = 'dropdown',
}: {
  variant?: 'dropdown' | 'horizontal'
}) {
  const pathname = usePathname()
  const { locale: currentLocale } = useParams() as { locale: Locale }
  
  // 提取当前路径中的语言代码后的部分
  const pathnameWithoutLocale = pathname.split('/').slice(2).join('/')
  
  // 根据变体渲染不同样式的语言切换器
  if (variant === 'horizontal') {
    return (
      <div className="flex items-center space-x-4">
        {locales.map((locale) => (
          <Link
            key={locale}
            href={`/${locale}/${pathnameWithoutLocale}`}
            className={locale === currentLocale ? "active" : ""}
          >
            {localeNames[locale]}
          </Link>
        ))}
      </div>
    )
  }
  
  // 默认下拉菜单样式
  return (
    <div className="relative">
      {/* 下拉菜单实现 */}
    </div>
  )
}
```

## 最佳实践

1. **组件分类原则**：
   - 如果组件在多个页面复用，使用公共翻译
   - 如果组件是特定页面或功能专用，使用私有翻译

2. **避免翻译键冲突**：
   - 公共翻译使用明确的命名空间
   - 私有翻译保持简洁直观的结构

3. **默认值处理**：
   - 总是提供默认值，避免显示空白或错误
   - 英文作为最终回退语言

4. **维护与更新**：
   - 定期检查翻译完整性
   - 新增功能时同步更新所有语言版本

5. **性能考虑**：
   - 预加载翻译文件，避免运行时加载
   - 对于大型应用，考虑按路由分割翻译文件

## 工作流程

1. **新增共享文本**：
   - 在所有语言的翻译文件中添加对应键值
   - 使用有意义的命名空间和键名

2. **新增私有组件**：
   - 在组件内创建翻译对象
   - 确保支持所有项目语言

3. **更新现有翻译**：
   - 修改对应的翻译文件或组件内翻译对象
   - 确保所有语言版本同步更新

4. **添加新语言支持**：
   - 在`i18n.ts`中添加新语言代码
   - 创建新语言的翻译文件
   - 更新所有私有组件的翻译对象 